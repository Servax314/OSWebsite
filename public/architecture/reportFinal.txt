--------------------- Miscelaneous ---------------------

Last but not least, I made the logo and the different illustrations.

--------------------- Architecture -------------------------
Clamp: 
The original idea with the clamp was to be able to grab several balls at the same time. Then, since we do not have a lot of motors available, the goal was to design a clamp that do not need any motorisation to size the balls. We ended up with this clamp (picture below). We use the tension of the rope to do the grabbing. The main advantages are that the balls do not need to be in a particular place to be grabbed (remove a lot of indeterminism). Hence the behaviour is very consistent.

The robot:
The robot is mostly symmetric. 
We put the sonar sensor on the side. Its position is the key element of our strategy. 

Ev3:
We put it here since it was easy to access it both to branch cables (sensors, motors and the alimentation) and to use the buttons.

Arm of the robot:
The design of a scissor-lift-like arm enable us to have a very good precision when lowering or lifting the clamp. A total of about 3500 tacho counts were needed to lower it.  
The main drawback with the design of the arm is that some mechanical pieces are stressed a lot when weights are added to the clamp. In addition, when the motors are overloaded, they lose some accuracy (tacho counts).

---------------------  Architecture team --------------------- 

I set up the robot and started to build it. I designed the main architecture (the base and the scissor-lift clamp) of the robot and then Nicolas optimized it (tuned the clamp, improved the stability and the solidity, …). 
At first, I thought about using a poly-articulated arm, but the movement of the clamp would have been rather complicated. Using just a simple clamp and using the robot to position it at the right position (a colour sensor to detect a ball) appeared to me like an easier option. After, spending hours on testing different configurations, designing some clamps, I finally ended up with the idea of a clamp that do not need any motor to size a ball, in addition to be able to catch several balls at the same time. I built several different clamps and spent an entire day on that to the point that my roommates were making fun of me "playing" Legos all day long (sweeter memory in my childhood however). The scissors lift was quite a challenging part.
Since getting familiar with the sensors (lot of tests and empirical tunning) may require a lot of time and complexity in this context, I tried to look at an easy way to use them without introducing too much indeterminism. It really pushes me to understand how to use sensors, how to couple them and how to deal with their inaccuracy.

---------------------  Algorithm --------------------- 
Warehouse game: 
 
The strategy is based on “replication”. 
An illustration of the strategy is provided below:

[ ------------
picture of the 
--------------
strategy 
------------- ]

The different variables are the corner stone of the strategy: 

bool loaded_robot;
bool edge_detected; 
bool obstacle_touched;
bool empty;
bool destination_container;
int heading; // -1 south / +1 north (top of the map) 
int robot_y_position;

The different functions (names are self-explanatory):  

find_next_container:
This function is responsible to find the next container in the map. For that, the function needs to monitor if an edge is detected (edge_detected). It also needs the heading of the robot to position it. Furthermore, it needs to know if the unknown cube has already been spotted or not (unknown_cube) to perform the move_toward_the_wall function. 

type_of_container:
To know the type of the container spotted by the sonar we need to know:
- the heading of the robot 
- the position of the robot on the y axis 
- the positions of all the containers on the y axis 
Examples:
If the robot is in the first zone (unknown zone) then the cube is the unknown cube.
If the robot heads north (top of the map) then the cube is a cube containing balls.

container_is_adapted:
To know whether or not the container is adapted we have to look at different flags:
- loaded_robot  
- flags of the container (empty, destination_container) 
Examples: 
The container is adapted if the robot is loaded and the container is a container where we have to put balls. We can have additional constraints: previous conditions + the cube has to be empty.

go_to_container:
To go to the container spotted we need to know the heading of the robot and the action to perform (grabbing or releasing the balls) when the cube is hurted (obstacle_touched). 

The unknown cube can have a random angle compare to the others, thereby to apply our “replication” approach, we program the robot to push the cube toward the wall to make it parallel to it. From there, we just need to move the robot backward, make a quarter turn, move backward again and then we can go anew to the first step of the process but this time we know that the unknown cube is in a right position – it will be considered as normal cube.  
This approach allows to use the sensors and the robot in a very simple manner. Hence, the behaviour is consistent. In addition, we can update the model quite easily and change the strategy according to our needs. 

--------------------- Algorithm team --------------------- 

I designed, coded the strategy, and made the code integration. Nicolas helped me to debug the file. 
At first the algorithm part was quite challenging. The fact that we cannot meet in person and work physically with the robot make the whole process harder. I tried to find a strategy that would be simple to explain, debug, test and collaborate on. The simple idea that came to my mind was “replication”. I tried to design a way for the robot to always do the same thing when it spots a container. 
At the beginning of the project, Brehima did not know how to access the position of the robot so I tried to figure out a way to get around this. I finally came up with the idea of putting the sonar sensor at a side of the robot and the touch sensor at the front. I have learned through this, how to use in an efficient way “flags” to code the strategy. With this approach the robot can adapt to several configurations. It was a plus since we did not know at the time how the arena would be. 
Above all, this project has been a godsend for learning C. I took the C training course offered by Open Classroom in parallel and was able to put the things I learned into practice. It really helped me take the plunge!  
 
## thread part: 

I first wrote the program without the use of threads. However, in case we need to do more complex actions I decided to use one thread dedicated to the sonar sensor. 
I realized that there are different ways to share data among the threads. In our program, I used structures that contain pointers. It was for clarity sake since we manipulate a lot of data.

The simple C program below explain the structure of the code and its expected behaviour:

----------------------------
/*
One thread modifies a variable and another prints it. 
The output is:
3 3 2 2 1 1 
booooom !!
booooom !!
...
*/

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct args1 {int* a;} args1;
typedef struct args2 {int* a;} args2;

void args_init1(args1* args,int* a){args->a= a;}
void args_init2(args2* args,int* a){args->a= a;}


void *print_a(void *input) {
	args1* arg = input;
	sleep(1);
	while(1){
		while( *(arg->a)>0 ){sleep(1); printf("%d ",*(arg->a));}
		printf("\nbooooom !!"); 
	}
}

void *modify_a(void *input) {
	args2* arg = input;
	while(1){sleep(2); *(arg->a) -=1;}
}

int main() {
	int a = 4; 
	args1 A1;
	args2 A2;
	args_init1(&A1,&a);
	args_init2(&A2,&a);

	pthread_t t1, t2;
	int err1 = pthread_create(&t1, NULL, print_a, (void *)&A1);
	int err2 = pthread_create(&t2, NULL, modify_a, (void *)&A2);
	if(err1||err2) { printf("thread error");}
	
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	
	return 0;
}
----------------------------























